# Next.js 13 Course Summary

This repository contains the key concepts and code examples from the Fireship.io Next.js 13 course. It serves as a concise guide to quickly grasp the fundamentals of Next.js 13.

## 1. üöè APP ROUTER

### File System-Based Routing

In Next.js, routes are defined by the file system. Each route segment corresponds to a directory with a page component inside of it. This component renders the UI for that route. For example, a file named `pages/about.js` will route to `www.yourwebsite.com/about`.

### Link Component

To navigate between pages, Next.js provides a built-in `<Link>` component. It works like an HTML `<a>` tag but uses a more sophisticated client-side routing instead of a full page reload, making navigation faster. 

```jsx
<Link href="/about">About Us</Link>
// creates a link to the about page.
```

### useRouter Hook

Next.js also provides the `useRouter` hook for programmatically changing the route or refreshing the page. For example:

```jsx
import { useRouter } from 'next/router'

function NavigationButton() {
  const router = useRouter()

  const goToHome = () => {
    router.push('/')
  }

  return <button onClick={goToHome}>Go Home</button>
}
```
### Accessing Route Parameters

Route parameters can be accessed in server components via the params object. Inside your page component, Next.js provides the value of the route parameter through a `params` object.

```jsx
// app/blog/[slug]/page.tsx

const { slug } = params
```

### Catch-All Routes

By using three dots (...) in front of the parameter name, you can create a catch-all route to handle all nested route segments. For example, a file named pages/posts/[...id].js will match www.yourwebsite.com/posts/1/2/3, etc.

### Route Groups

By adding parentheses to a folder name, you can create a route group. This has no effect on the actual URL structure but allows you to organize your code into related features. For example, a directory named pages/blog/(author) will group all files inside the (author) directory under the blog route.

### Parallel routing

Advanced pattern that creates a name slot that can be accessed in a parent layout, allowing you to render multiple pages on the same route with different slots. 

## 2. üö¶ ROUTE HANDLERS


Route handlers are based on the request / response interface from the fetch API.
Route Handlers are defined in a `route.js` or `route.ts` file and can be nested inside the app directory, but there cannot be a route.js file at the same route segment level as page.js.

They are the equivalent of API Routes inside the `pages` directory, meaning you don't need to use both API Routes and Route Handlers together.

Route handlers are useful when rendering UI is no needed and just want an API endpoint that returns JSON, text, or other kind of response.

Route Handlers support the following HTTP methods: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called, Next.js will return a 405 Method Not Allowed response.

```jsx
// app/user/route.ts
export async function PUT(req, res) {
 const session = await getServerSession(authOptions);
 const currentUserEmail = session?.user?.email!;


 const data = await req.json();
 data.age = Number(data.age);


 const user = await prisma.user.update({
   where: {
     email: currentUserEmail,
   },
   data,
 });


 return res.json(user);
}
```

## 3. üé® LAYOUTS
A Layout is UI shared between multiple pages. You can define a layout by default exporting a React component from a layout.js file.

The top-most layout is called the Root Layout. This required layout is shared across all pages in an application and comes generated by default. 

Any route segment can optionally define its own Layout, it will be shared across all pages in that segment.

Layouts can be nested. A layout defined inside a folder applies to specific route segments and wraps child layouts via their children prop. They can also be combined with route groups and folders named with parenthesis. 

Layouts can fetch data.

Layouts preserve state, remain interactive, and do not re-render. Instead of layouts you can use templates, works the same way but a new instance of the component is mounted, DOM elements are recreated, state is not preserved, and effects are re-synchronized.

```jsx
// app/layout.tsx
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body> 
    </html>
  )
}
// children represent a page rendered or route segment
```

## 4. üñºÔ∏è RENDERING AND SEO

Next.js is a popular meta-framework for its server-side rendering (SSR) capabilities, which are crucial for search engine optimization (SEO). However, Next.js 13.4 introduces a more simplified mental model with Server Components.

### Server Components

By default, you should make every page a Server Component. As the name implies, these components are rendered on the server, which is good for SEO. However, if you want to use client-side features like `useEffect` in React, you'll need to move your interactive code into their own Client Components.

### Caching 
Caching stores data so it doesn't need to be re-fetched from your data source on every request.

By default, Next.js automatically analyzes your data fetching code and caches the returned values of fetch in the Data Cache on the server. 

Next.js will automatically try to cache your pages to provide fast page loads with the most up-to-date data. It does this by . Every page has a dynamic option that you can export, set to `auto` by default.

### Dynamic Option
Every page has a dynamic option that you can export that is set to Auto by default.

If you change the dynamic option to `forceDynamic`, it will use SSR without caching. This is ideal for pages that rely on data that changes very often.

```jsx
export const dynamic = 'force-dynamic'
```
If you change the dynamic option to `forceStatic`, it will tell Next.js to cache the page indefinitely. This is ideal for a page where the data never changes.

```jsx
export const dynamic = 'force-static'
```

There's also a `revalidate` option that allows you to regenerate a static page after a certain number of seconds have elapsed.

```jsx
export const revalidate = '6900'
```

### Metadata

For SEO, you can export a `metadata` variable that contains information like the title and description of the page. This can be done in any page or layout file, and the values will be automatically added to the head of the document. If the data is dynamic, you can also export a `generateMetadata` function to create these values on the fly.

```jsx
export const metadata = {
  title: 'Page Title',
  description: 'Page Description',
};

export async function generateMetadata() {
  const data = await fetch('https://api.example.com/data').then(res => res.json());
  return {
    title: data.title,
    description: data.description,
  };
}
```

## 5. üìä DATA FETCHING

In Next.js 13.4, every layout and page is a Server Component, which can access server-side resources like environment variables and databases without the need to pass props to the component. This simplifies data fetching and improves performance.


Server Components can be async, allowing you to use `async/await` just like a regular function. You can use Prisma, the Firebase SDK, or the Fetch API to grab data with a single line of code, and there's no need to pass it as props down to a child component.

```jsx
export default async function Page() {
  const data = await fetch('https://api.example.com/data').then(res => res.json());

  return <main>{/* ... */}</main>;
}
```

### Parallel Data Fetching

If you have nested layouts and a page each doing its own data fetching, Next.js fetches everything in parallel. This can dramatically improve the rendering time and time to interactive for a webpage.

### Automatic Request Deduping

Next.js automatically keeps track of any fetch calls that use the same inputs, preventing unnecessary API calls and network usage. You don't have to worry about fetching the same data multiple times.

### Caching

You can control the caching behavior of fetch by passing in an object with an optional cache property. For static data, you can force it to use the cache. For highly dynamic data, you can specify `no-store` to never use the cache.

```jsx
// This request should be cached until manually invalidated.
const a = await fetch(URL, { cache: 'force-cache' });

// This request should be refetched on every request.
const a = await fetch(URL, { cache: 'no-store' });
```

For everything in between, the `revalidate` option allows you to specify a certain number of seconds at which point the cache will be invalidated and the next fetch call will generate new data.

## 6. üåä STREAMING AND SUSPENSE

### Streaming

These steps involved in rendering a web page are sequential, and a complex application might need to fetch a lot of data could result in a slow page load. 

Streaming in Next.js works by breaking the application into smaller chunks to load things progressively.
Next.js handles streaming automatically, but you can leverage it to improve the user experience by adding additional components to a route like a loading file.

```jsx
// This is a loading component
export default function Loading() {
  return <div>Loading...</div>;
}
```
Next.js will automatically render that loading component first while data is being fetched and the page component is being rendered. 

### Suspense

React Suspense is the magic that makes this possible. Suspense is a special component in React that creates a suspense boundary. It works by wrapping a component that does something asynchronous, like fetching data, then shows a fallback UI until that async operation is done.

```jsx
import { Suspense } from 'react';

// This is a Suspense component
<Suspense fallback={<div>Loading...</div>}>
  <Page />
</Suspense>
```

You can use Suspense directly in a Next.js application, which can provide more granular control over the UI but in most cases, creating a loading page is the ideal way to go.

## 7. üîí AUTH.JS

Auth.js is a universal open source user authentication system for the web. It provides tools to implement passwordless strategies such as email link sign in, OAuth with various providers, or your own custom logic like phone SMS verification. It can run in any server environment, be used with any modern front-end framework, and can connect to any database.

### Universal Database Model

Auth.js provides a universal database model for users, accounts, and sessions that can be adapted for any database. When a user signs in, the default strategy is to generate a JSON Web Token (JWT), which is stored client-side. However, you can also store the session server-side by changing the strategy to database.

### Auth.js Setup

To install NextAuth.js, you can use npm (Node Package Manager). Install it in the same directory where your Next.js application is located.
`npm install next-auth`

Add an API route that exports your configuration options. Here a variety of different providers can be added like GitHub, Google, and Facebook sign in, or use credentials to implement your own custom authorization logic.

```jsx
// pages/api/auth/[...authoptions].js

export const AuthOptions: NextAuthOptions = {
  providers: [
    GithubProvider({
      clientId: process.env.GITHUB_ID,
      clientSecret: process.env.GITHUB_SECRET
    })

    // ...add more providers here
  ],
}
```

It can be used without a database, but you can easily add a database adapter to store user data. 
This code creates different API routes that handle the entire authentication flow.

### Session Provider

You can add the Session Provider component to the root of the application to keep track of the current user.

```jsx
// app/AuthProvider.tsx

export default function AuthProvider({ children }: Props) {
  return <SessionProvider>{children}</SessionProvider>;
}

```

### useSession hook

Any child component can take advantage of the `useSession` hook to listen to updates to the user in real time. It also provides functions to sign in and sign out that can be bound to a button.

```jsx
// app/components/AuthCheck.tsx

'use client';

import { useSession } from 'next-auth/react';

export default function AuthCheck({ children }: { children: React.ReactNode }) {
  const { data: session, status } = useSession();

  console.log(session, status);

  if (status === 'authenticated') {
    return <>{children}</>;
  } else {
    return <></>;
  }

  return <button onClick={() => signIn()}>Sign in </button>
 
}

// app/components/buttons.tsx

import { useSession, signIn, signOut } from 'next-auth/react';

export function SignInButton() {
  const { data: session, status } = useSession();
  console.log(session, status);

  if (status === 'authenticated') {
    return <>{children}</>;
  } else {
    return <></>;
  }

  return <button onClick={() => signIn()}>Sign in</button>;
}

export function SignOutButton() {
  return <button onClick={() => signOut()}>Sign out</button>;
}
```
### getServerSession hook

You can also check the authentication state server-side with the `getServerSession` function. This makes Auth.js extremely powerful because it allows you to check the user authentication state from both front-end and back-end code.

```jsx
// app/api/route.ts

export async function POST(req: Request) {
  const session = asait getServerSession()
}
```

## üóÑÔ∏è PRISMA

Prisma is an open-source tool that simplifies database interaction by providing a declarative schema language and type-safe CRUD operations. It makes database management more efficient and concise.

## Getting Started with Prisma

1. **Installation**: Prisma can be set up in a Node.js project with MongoDB support using the command `npx prisma init`.

```jsx
npx prisma init
```

2. **Schema Definition**: Define the schema in the `prisma` directory. This includes column names, data types, and constraints.

```prisma
model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}
```
3. **Introspection**: Run `prisma db pull` to introspect an existing database and automatically generate the schema from it.

```jsx
npx prisma db pull
```
4. **Simplicity**: Prisma code is more concise than raw SQL, especially when modifying the schema.

5. **Efficiency**: Prisma simplifies database interaction and automatically handles database structure modifications, generating client libraries and allowing for easy filtering and joining of related tables.

## 9. üåü OTHER FEATURES

### Image Optimization 

Next.js has a built-in feature for optimizing images that automatically serves correctly sized images for each device, using modern image formats like WebP and AVIFHowever.

```jsx
import Image from 'next/image'
 
export default function Page() {
  return (
    <Image
      src="https://s3.amazonaws.com/my-bucket/profile.png"
      alt="Picture of the author"
      width={500}
      height={500}
    />
  )
}
```

## Remote Images Optimization

If you want to optimize images that are stored on a different website (remote images), you need to add a special configuration in your `next.config.js` file. This tells Next.js that it's okay to download and optimize these images.

``` jsx
module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 's3.amazonaws.com',
        port: '',
        pathname: '/my-bucket/**',
      },
    ],
  },
}
```
## Error UI

```jsx
The `error.js` file convention allows you to gracefully handle unexpected runtime errors in nested routes. 

// pages/products/error.js
export default function Error({ error }) {
  return (
    <div>
      <h1>Error:</h1>
      <p>{error.message}</p>
    </div>
  );
}
```

## 10. üöÄ ADVANCED

### üéõÔ∏è Server Actions in Next.js

Next.js has introduced a feature called server actions. This simplifies server-side coding by allowing you to write server-side functions alongside your server components. This eliminates the need for creating individual API routes for data mutation. It integrates seamlessly with the React front-end without needing to completely reload the page like traditional PHP apps. Please note that the Server Actions feature is still in alpha stage, meaning it's being tested and may not be fully stable or feature-complete.

### üìù Handling Form Submissions and Database Updates

Server actions in Next.js can be used to handle form submissions and update data in your database. This simplifies the process of creating an API route and a client component.

### üì® Passing Form Data to Server-side Functions

Next.js allows you to pass form data to server-side functions using the "action" property. You can define async functions with the "use server" directive.

### üîÑ Updating Form Data

You can update the database with form data through a mutation in Next.js. This can be done using the revalidate path to automatically update the UI. You can also add a loading component for a skeleton UI.

### üéØ Performing Multiple Actions on the Same Form

You can perform multiple actions on the same form in Next.js. For example, one button can update the database and redirect to the main profile page, while another button can perform any other desired action.

### üåê Defining Server Actions Outside of Server Component

Server actions can be defined outside of the server component and reused in any component. However, they can only be triggered from elements inside a form.

### ü™ù Use Transition Hook

The client component uses the use transition hook to execute server actions and update state without blocking the UI.

### üîÑ Using Server Components and Actions with Optimistic Updates

Server components simplify the process of running mutations and refetching data. Actions can support optimistic updates to reduce latency. The Hook combines use transition and use reducer to update the UI instantly and sync up the True Value when the server responds. You can define a reducer function to update the latest value and use server actions to update a value that we think the light count will be, making the server look extremely fast.
